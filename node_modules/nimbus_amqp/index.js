var util = require('util');
var EventEmitter = require('events').EventEmitter;
var amqp = require('amqp');

"use strict";

function Amqp(){
    EventEmitter.call(this);
};

function encode_mongo_basic_data(data)
{
    var i, k, type;

    if (data instanceof Array){
        for(i in data){
            data[i] = encode_mongo_basic_data(data[i]);
        }
    } else if (data instanceof Date){
        data = { "$date" : data.toString()};
    } else if (data instanceof Buffer){
        if (data.bd_type){
            type = data.bd_type;
        }else{
            type = 0;
        }
        data = {"$binary" : data.toString('base64'), "$type": type };
    } else if (data instanceof Object){
        for (k in data){
            if (data.hasOwnProperty(k)){
                data[k] = encode_mongo_basic_data(data[k]);
            }
        }
    }
    return data;
}


module.exports = new(function(){
    var self = this;

    this.factory = function(options, callback){
		if (!options.host && process.env.RABBITMQ){
			var env_rabbit = process.env.RABBITMQ;

			if (env_rabbit.indexOf(';') != -1){
				env_rabbit = env_rabbit.split(';');
			}
			options.host = env_rabbit;
		}
//		console.log(options.host);
        if (!options || !options.host){
            callback(new Error("Amqp host required! In raindrops add this line: .let('amqp', {host: '<amqp host>'})"));
            return null;
        }
        var a = new Amqp();
        a.init(options);
        a.once('ready', function(ready_object){
            callback(null, a);
        });
        return a;
    }
});

Amqp.prototype = new EventEmitter();
util.inherits(Amqp, EventEmitter);

Amqp.prototype.init = function(properties){
    var key;
    var self = this;
    var initialised_exchanges = 0;

    this.host = ['rabbitmq-03.devel.nimbus'];
    this.vhost = '/';
    this.default_prefetch_count = 5;
    this.heartbeat = 30;
    this.exchanges = {};
    this.maxLength = 10*1024*1024;
    //	this.exchanges = { my_tasks : {  type: 'topic', durable:'true'}};
    //	this.queues = { test1: { prefetch_count : 5, on_message: log_on_message, callback: on_queue_initialised};
    this.queues={};
    this.reconnect_interval = 2;
    this.publish_listeners = 10;
    this.transform_function = encode_mongo_basic_data;
    this.max_buffer_size = 0;

    for (key in properties) {
        this[key] = properties[key];
    }

    if (typeof(this.host) == 'string'){
        this.host = [this.host];
    }
    this.emitted_ready = false;
    this.failed_connections = [];
    this.active_connections = {};
    this.unsubscribing = false;
    for (key=0; key < this.host.length; key++){
        this.failed_connections.push(this.host[key]);
    }
    this.reconnection_timer = setInterval(function(){
        self.reconnect();
    }, this.reconnect_interval * 1000, this);
    if (self.exchanges){
        this.on('exchange_initialised', function(exc){
            if (++initialised_exchanges == Object.keys(self.exchanges).length){
                self.emit_ready();
            }
		});
		for (var exchange in self.exchanges){
			this[exchange] = {};
			this[exchange].publish = this.get_publish_function(exchange);
		}
    }
    this.reconnect();
    this.publish  = this.get_publish_function('__default__');
};

Amqp.prototype.close = function(){
    clearInterval(this.reconnection_timer);
    this.forEachActiveConnection(function(connection){
        connection.emit('close');
    });
}

Amqp.prototype.forEachActiveConnection = function( callback ){
    var i;
    for (i in this.active_connections){
        callback(this.active_connections[i]);
    }
}

Amqp.prototype.unsubscribe = function (callback){
    var c = 0;

    this.queues = {};
    if (this.unsubscribing){
        return;
    }
    this.unsubscribing = true;
    this.forEachActiveConnection(function(connection){
        var ctag;
        for (var i in connection._bd_queues){
            if (connection._bd_queues[i].__ctag){
                c++;
                ctag = connection._bd_queues[i].__ctag;
                connection._bd_queues[i].__ctag = null;
                connection._bd_queues[i].unsubscribe( ctag ).
        addCallback(function(){
            c--;
            if (c==0 && callback){
                callback();
            }
        });
            }
        }
    });
}

Amqp.prototype.emit_ready = function(){
    if (!this.emitted_ready){
        this.emit('ready', this);
        this.emitted_ready = true;
    }
}

Amqp.prototype.reconnect = function(){
    var i, len, current_host;
    var self = this;

    len = this.failed_connections.length;
    for (i = 0; i < len; i++){
        current_host = this.failed_connections.shift();
        this.try_rabbit_connection(
                current_host,
                function(host, connection){
                    self.active_connections[host] = connection;
                    connection._bd_exchanges['__default__'] = {publish : function(rk, msg, opt){
                        connection.publish(rk, msg, opt);
                    }};
                    if (!Object.keys(self.exchanges).length){
                        self.emit_ready();
                    }
                    if (self.exchanges){
                        for (var exchange in self.exchanges){
                            self.__init_exchange(exchange, self.exchanges[exchange], connection);
                        }
                    }
                    if (self.queues){
                        for (var queue in self.queues){
                            self.__init_queue(queue, self.queues[queue], connection, self.queues[queue].callback);
                        }
                    }
                },
                function(connection){
                    self.failed_connections.push(connection);
                    delete self.active_connections[connection];
                    //console.log("Failed connection!!!", self.failed_connections, self.active_connections);
                    self.emit_ready();
                });
    }
}

Amqp.prototype.declare_queue = function(name, definition, callback){
    var self = this;
    var active_length = Object.keys(self.active_connections).length;
    var declared = 0;

    if (!self.queues){
        self.queues = {}
    }
    self.queues[name] = definition;
    self.forEachActiveConnection(function(connection){
        self.__init_queue(name, definition, connection, function(q){
            if (++declared == active_length){
                if (callback)
            callback();
            }
        });
    });
    if (active_length == 0 && callback){
        callback();
    }

}

Amqp.prototype.__init_queue = function(name, definition, connection, callback){
    var self = this;
    if (this.unsubscribing){
        if (callback){
            callback(new Error("unsubscribing"));
        }
        return;
    }
    //console.log(name, definition,  definition.on_message);
    if (connection._bd_queues[name]){
        if (definition.bind && connection._bd_queues[name] != 'in_progress'){
            connection._bd_queues[name].bind(definition.bind.exchange, definition.bind.routing_key);
        }
        return;
    }
    if (!definition.prefetch_count){
        definition.prefetch_count = 1;
    };
    if (! definition.hasOwnProperty('durable')){
        definition.durable = true;
    }
    if (! definition.hasOwnProperty('autoDelete')){
        definition.autoDelete = false;
    }
    connection._bd_queues[name] = 'in_progress';

    q = connection.queue( name, definition, function(queue){
        connection._bd_queues[name] = queue;
        var ack = true;
        if (definition.hasOwnProperty('ack')){
            ack = definition.ack;
		}
        if (definition.bind){
			queue.bind(definition.bind.exchange, definition.bind.routing_key);
		}
		if (definition.on_message){
        	queue.subscribe({ack:ack, prefetchCount: definition.prefetch_count}, definition.on_message)
				.addCallback(function(ok){
	            if (this.unsubscribing){
    	            queue.unsubscribe(ok.consumerTag);
	            }else{
    	            connection._bd_queues[name].__ctag = ok.consumerTag;
	            }
        	});
 	   }
       if (callback){
            callback(queue);
       }
    });
    q.on('error', function(err){
        self.emit('error', err, q);
    });
}

Amqp.prototype.declare_exchange = function(name, definition, callback){
    var self = this;
    var active_length = Object.keys(self.active_connections).length;
    var declared = 0;

    if (!self.exchanges){
        self.exchanges = {}
    }
    self.exchanges[name] = definition;
    if (!definition.initialised){
      self[name] = {};
      self[name].publish = self.get_publish_function(name);
      self.emit('exchange_initialised');
    }
    definition.initialised = true;
    self.forEachActiveConnection(function(connection){
        self.__init_exchange(name, definition, connection, function(){
            if (++declared == active_length){
                if (callback){
                    callback();
                }
            }
        });
    });
    if (active_length == 0 && callback){
        callback();
    }
}

Amqp.prototype.__init_exchange = function(name, definition, connection, callback){
    var self = this;
    var exchange = null;

    if (! ('durable' in definition)){
        definition.durable = true;
    }
    var e = connection.exchange(name, definition, function(exc){
        connection._bd_exchanges[name] = exc;

//        console.log("MAX", self.publish_listeners, exc);
        exc.setMaxListeners(self.publish_listeners);


        if (!definition.initialised){
            self[name] = {};
            self[name].publish = self.get_publish_function(name);
            self.emit('exchange_initialised');
        }
        definition.initialised = true;

        if (callback){
            callback(exc);
        }
    });
    e.on('error', function(err){
        self.emit('error', err, e);
    });
}

Amqp.prototype.get_publish_function = function(exchange_name){
    var self = this;

    return function(routing_key, message, options, callback){
        var got_error, last_error;
        var i = 0, sent_callback;
        var length = 0;

		function respond_next_tick(err){
			process.nextTick(function(){
				callback(err);
			});
		}
        if (typeof(options) == 'function'){
            callback = options;
            options = {};
        }
        if (!Object.keys(self.active_connections).length){
            //  console.log(self.active_connections);
			if (callback){
                respond_next_tick(new Error("No active connections"));
            }
            return;
        }

        if (typeof(message) == 'string') {
            length = Buffer.byteLength(message);
        } else if (message instanceof Buffer){
            length = message.length;
        } else {//JSON
            var tmp = JSON.stringify(message);
            length = tmp.length;
        }

        if (length > self.maxLength){
            if (callback)
                respond_next_tick(new Error("Maximum message length exceeded " + length + ' '+ self.maxLength));
            return;
        }
        if (self.transform_function){
            try{
                self.transform_function(message);
            }catch(x){
				// console.log("Tranform error: ", x);
				respond_next_tick(x);
				return;
            }
        }
        got_error = true;
		last_error = "No available exchange";

		sent_callback = null;
		if (exchange_name !== '__default__' && self.exchanges[exchange_name].confirm){
			sent_callback = callback;
        }
        for (var i in self.active_connections){
            got_error = false;
            if (self.active_connections[i].bufferSize &&
                self.max_buffer_size &&
                self.active_connections[i].bufferSize > self.max_buffer_size){
                last_error = 'Maximum buffer size exceded';
                continue;
            }
            if (self.active_connections[i]._bd_exchanges[exchange_name]){
                try{
                    self.active_connections[i]._bd_exchanges[exchange_name].publish(routing_key, message, options, sent_callback);
                }catch(err){
                    last_error = err;
                    self.active_connections[i].destroy();
                    got_error = true;
                }
            }
			if (!got_error){
				if (callback && (exchange_name == '__default__' || !self.exchanges[exchange_name].confirm)){
					respond_next_tick(null);
				}
                return;
            }
        }
        // console.log("GOT error", last_error);
        if (callback){
            respond_next_tick(last_error);
        }
    }
}

Amqp.prototype.try_rabbit_connection = function(host, success_callback, error_callback)
{
    var self = this;
    var tmp;
    var interval = null;

    try {
        tmp = amqp.createConnection({
				host: host,
	            heartbeat: self.heartbeat,
	            vhost: self.vhost
			  },
			  { reconnect:false }
		);
    }catch(err){
        error_callback(err);
    }
    tmp._bd_called_destroy = false;
    tmp._bd_queues = {};
//    tmp.setTimeout(3 * 1000 * self.heartbeat);

//    tmp.on('heartbeat', function(){
//        tmp.heartbeat();
//    });

    tmp.on('ready', function(){
		/*        interval =  setInterval(function(){
            tmp.heartbeat()
		}, self.heartbeat * 500);
		*/
        tmp._bd_exchanges = [];
        success_callback(host, tmp);
    });

    function reconnect(err){
        if (err){
            err = err.stack;
            self.emit('warn', 'Error on connecton', host, err);
        }else{
            self.emit('warn', 'Connection lost to ', host);
        }
        error_callback(host);
    }

    function destroy(){
        if (!tmp._bd_called_destroy){
            tmp._bd_called_destroy = true;
            clearInterval(interval);
            tmp.destroy();
            reconnect();
        }
    }
    tmp.on('end', destroy);
    tmp.on('error', destroy);
    tmp.on('timeout', destroy);
    tmp.on('close', function(){
        self.emit('warn', 'Rabbit: got close');
        destroy();
    });
}

function log_on_message(msg, header, deliveryInfo){
    console.log("Amqp: Got message", msg, header, deliveryInfo);
}
